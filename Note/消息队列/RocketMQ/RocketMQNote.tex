\documentclass[11pt, a4paper, oneside, fontset=none]{ctexbook}
\usepackage{amsmath, amsthm, amssymb, bm, graphicx, hyperref, mathrsfs, enumitem, geometry, listings, xcolor, listings, fontspec, caption, unicode-math}

% 标题、作者、创建日期
\title{{\Huge{\textbf{RocketMQ}}}\\学习笔记}
\author{寿命齿轮}
\date{2024年1月20日}

% 设置全局字体
\setmainfont{TeX Gyre Termes}
\setmathfont{TeX Gyre Termes Math}

% 中文默认字体：方正书宋_GBK，粗体为思源宋体半粗体，斜体为方正楷体_GBK
\setCJKmainfont[Path=../../../fonts/, BoldFont=SOURCEHANSERIFCN-MEDIUM-6.otf, ItalicFont=FANGZHENGKAITI-GBK-1.ttf]{FANGZHENGSHUSONG-GBK-1.ttf}
% 中文无衬线字体：方正黑体_GBK，粗体为思源黑体中粗体
\setCJKsansfont[Path=../../../fonts/, BoldFont=SOURCEHANSANSSC-MEDIUM-2.otf,AutoFakeSlant]{FANGZHENGHEITI-GBK-1.ttf}
% 中文等宽字体：方正仿宋_GBK
\setCJKmonofont[Path=../../../fonts/]{FANGZHENGFANGSONG-GBK-1.ttf}
\newCJKfontfamily\songti{FANGZHENGSHUSONG-GBK-1.ttf}[Path=../../../fonts/, BoldFont=SOURCEHANSERIFCN-MEDIUM-6.otf,AutoFakeSlant]
\newCJKfontfamily\xbsong{SOURCEHANSERIFCN-MEDIUM-6.otf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\dbsong{SOURCEHANSERIFCN-BOLD-2.otf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\cusong{SOURCEHANSERIFCN-HEAVY-4.otf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\heiti{FANGZHENGHEITI-GBK-1.ttf}[Path=../../../fonts/, BoldFont=SOURCEHANSANSSC-MEDIUM-2.otf,AutoFakeSlant]
\newCJKfontfamily\dahei{SOURCEHANSANSSC-MEDIUM-2.otf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\cuhei{SOURCEHANSANSSC-BOLD-2.otf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\fangsong{FANGZHENGFANGSONG-GBK-1.ttf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\kaiti{FANGZHENGKAITI-GBK-1.ttf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]
\newCJKfontfamily\kaishu{FANGZHENGKAITI-GBK-1.ttf}[Path=../../../fonts/,AutoFakeBold,AutoFakeSlant]

% 设置页面的尺寸和布局。
\geometry{a4paper,scale=0.75}

% 行间距为1.5倍
\linespread{1.5}

% 生成的书签大纲包含章节序号
\hypersetup{
  bookmarksnumbered=true
}

% 定义定理环境
\newtheorem{theorem}{定理}[chapter]
\newtheorem{definition}[theorem]{定义}
\newtheorem{lemma}[theorem]{引理}
\newtheorem{corollary}[theorem]{推论}
\newtheorem{example}[theorem]{例}
\newtheorem{proposition}[theorem]{命题}

% 自定义配置
% 设置全局的 enumerate、itemize 环境项之间的距离
\setlist[enumerate]{itemsep=-1pt, parsep=0pt, leftmargin=20pt, topsep=5pt, partopsep=0pt}
\setlist[itemize]{itemsep=2pt, parsep=0pt, leftmargin=20pt, topsep=5pt, partopsep=0pt}

% 定义新环境
% 定义颜色
\definecolor{commentcolor}{RGB}{182,73,1}
% 定义代码
\lstnewenvironment{java}[1][]{
  \lstset{
    language=Java,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{commentcolor},
    showstringspaces=false,
    breaklines=true,
    breakindent=0pt,
    frame=single,
    flexiblecolumns=true,
    backgroundcolor=\color{gray!5},
    numbers=left,
    numberstyle=\tiny,
    #1
  }
}{}
\lstnewenvironment{plsql}[1][]{
  \lstset{
    language=SQL,
    morekeywords={BEGIN,DECLARE,END,IF,ELSE,ELSIF,LOOP,WHILE,PROCEDURE,FUNCTION},
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{commentcolor},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    flexiblecolumns=true,
    backgroundcolor=\color{gray!5},
    numbers=left,
    numberstyle=\tiny,
    #1
  }
}{}
% 定义代码环境：XML文本
\lstnewenvironment{xml}[1][]{
  \lstset{
    language=XML,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{purple},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    flexiblecolumns=true,
    backgroundcolor=\color{gray!5},
    numbers=left,
    numberstyle=\tiny,
    #1
  }
}{}

% 定义代码环境：YAML文本
\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{darkgray}\bfseries,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstnewenvironment{yaml}[1][]{
  \lstset{
    language=YAML,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{purple},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    flexiblecolumns=true,
    backgroundcolor=\color{gray!5},
    numbers=left,
    numberstyle=\tiny,
    #1
  }
}{}

% 定义代码环境：Linux命令
\lstnewenvironment{bash}[1][]{
  \lstset{
    language=bash,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    breakindent=0pt,
    frame=single,
    flexiblecolumns=true,
    backgroundcolor=\color{gray!5},
    numbers=left,
    numberstyle=\tiny,
    #1
  }
}{}

% 定义一个名为ignore的新环境，表示不重要的内容。
\newenvironment{ignore}{%
  \color{gray}% 设置字体颜色为灰色
  \ignorespaces% 忽略环境前的空格
  （% 在灰色文本前添加左括号
}{%
  ）% 在灰色文本后添加右括号
  \ignorespacesafterend% 忽略环境后的空格
}

% 文章开始
\begin{document}

% 生成标题
\maketitle

% 生成作者的话
\newpage                    %新的一页
\pagenumbering{roman}       %页码以小写罗马数字形式表示
\setcounter{page}{1}        %设置当前页为第一页
\section*{作者的话}
本文用于记录作者在学习RocketMQ过程中所记录的笔记。

学习资料来源：
\begin{enumerate}
  \item \href{https://rocketmq.apache.org/zh/}{RocketMQ官网}
  \item \href{https://wx.zsxq.com/dweb2/index/footprint/544814425818214}{编程导航星球知识库：Yes大佬的消息队列专栏}
  \item 网上各类与消息队列相关的博客
\end{enumerate}

环境：
\begin{description}
  \item[系统] Ubuntu22.04(云服务器)
  \item[Java版本] 17
\end{description}

% 生成目录
\newpage                    %新的一页
\pagenumbering{Roman}       %页码以大写罗马数字形式表示
\setcounter{page}{1}        %设置当前页为第一页
\tableofcontents            %生成目录

% 生成内容
\newpage                    %新的一页
\pagenumbering{arabic}      %页码以阿拉伯数字形式表示
\setcounter{page}{1}        %设置当前页为第一页

% 文章内容
\chapter{消息队列：初识}
\section{介绍}
消息队列，顾名思义，存放\textbf{消息}（可类比为请求）的\textbf{队列}（一种先进先出的数据结构）。

其是一种常用于分布式系统的中间件，可以在不同的应用程序、服务或系统之间传递消息，并且常用于解耦合不同部分的系统，使得系统更加可扩展和灵活。

{\bfseries\kaishu 基本原理：发送者将消息放入队列，接收者从队列中获取消息并处理。}

消息队列实质是一种方式，一种{\bfseries\kaishu 在不同组件之间传递消息的通信方式}。发送者和接收者之间不需要直接通信，它们只需了解如何发送和接收消息即可。

\section{作用与优点}
由上述内容，可推断出消息队列的一些作用：
\begin{itemize}
  \item {\bfseries\kaishu 解耦：}发送者和接收者只需要关心发送消息和接受消息，不用关心彼此。
  \item {\bfseries\kaishu 异步：}发送者不关心消息的处理，即不用等待消息的响应，故支持异步。
  \item {\bfseries\kaishu 削锋：}某些活动的流量过大、请求过多，可能导致系统宕机；消息队列可以作为缓冲区，将这些请求暂时存储起来，以避免瞬时高流量，然后按照系统处理能力逐步消费，实现流量的平滑处理，从而降低系统的压力，避免宕机。
\end{itemize}

以及身为分布式系统的固有优点：
\begin{itemize}
  \item {\bfseries\kaishu 可扩展性：}在解耦后，可方便地单独对发送者或接收者或消息队列进行动态伸缩。
  \item {\bfseries\kaishu 可靠性：}由于消息队列允许多个消费者和生产者，并且通常支持消息持久化和复制，因此即使其中一个组件出现故障，系统仍然可以继续运行并且消息也不会丢失。
\end{itemize}

\section{适用场景}
（真实适用场景还是需要多实践才能掌握，这里仅介绍一些常用场景）
\subsection{异步场景举例：用户注册}
\subsubsection{需求}
用户注册后需向其发送注册邮件和注册短信。

\subsubsection{设计}
用户注册后，将注册信息写入数据库；发送注册邮件；发送短信。

如不使用消息队列，不进行异步解耦，即注册服务器需要同步远程调用写入数据库、发送注册邮件、发送短信的三个函数，将与其他应用发生多次交互，同时还得等待响应，假设一个操作需要0.5s，则该操作会占用注册服务器一个线程的1.5s。

使用消息队列后，注册服务器直接向消息队列中写入三个消息（数据库写入消息、邮件发送消息、短信发送消息），并且是异步发送不用等待返回，假设一次发送消息为0.1s，也仅需0.3s。

\subsection{解耦场景举例：订单-库存管理}
\subsubsection{需求}用户下订单后，库存系统需要减少相对数量。

\subsubsection{设计}
用户下单后，订单系统需要通知库存系统。

\subsubsection{详细设计}
原设计：订单系统调用库存系统的接口。存在缺陷：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；订单系统依赖库存系统接口，存在耦合。

改进后：订单系统发送订单消息（用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功），库存系统读取订单消息并自行处理（订阅订单消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作）。解决缺陷：假如库存系统无法访问，订单系统仅需要发送消息，可保持运转；订单消息仅发送消息，消息解读由库存系统进行（发布-订阅或消息队列模式），降低耦合度。

\subsection{削锋场景举例：秒杀活动}
\subsubsection{需求}在秒杀活动中，大量用户同时抢购商品，可能会导致系统压力激增。为了应对这一情况，需要一种机制来平稳处理激增的请求流量，避免系统崩溃或性能下降。

\subsubsection{设计}
传统的处理方式可能会导致系统崩溃或性能下降。为了解决这个问题，可以使用消息队列来削峰填谷。

\subsubsection{详细设计}
\begin{enumerate}
  \item 秒杀活动开始：当秒杀活动开始时，用户可以提交秒杀请求。
  \item 请求入队：订单系统接收到用户的秒杀请求后，将请求消息写入消息队列，而不是立即处理。
  \item 消息处理：秒杀请求消息被消息队列按照一定的规则（如先进先出）分发给后端处理程序。
  \item 后端处理：后端处理程序逐条处理消息，检查库存并进行相应的处理（如减少库存、生成订单等）。
\end{enumerate}

以此消息队列可平滑处理激增的请求流量，避免系统因突发流量而崩溃。

\subsection{日志处理场景}
\subsubsection{需求}
需要一种解决大量日志传输和实时处理的方案，以便对日志数据进行分析和可视化展示。

\subsubsection{设计}
设计一个分布式日志处理系统，包括以下组件：
\begin{enumerate}
  \item 日志采集客户端：负责从各个日志源采集日志数据，并将数据定期写入消息队列中。
  \item 消息队列：接收来自日志采集客户端的日志数据，负责数据的存储和转发。
  \item 日志处理应用：订阅并消费Kafka队列中的日志数据，进行实时处理和分析。
  \item Logstash：作为日志处理应用的一部分，负责对原始日志进行解析和转换，统一输出为JSON格式的数据。
  \item Elasticsearch：作为日志处理应用的核心数据存储服务，接收Logstash处理后的JSON格式日志数据，实现实时的数据索引和查询。
  \item Kibana：基于Elasticsearch的数据可视化组件，用于将Elasticsearch中的数据进行可视化展示和分析。
\end{enumerate}

\subsection{消息通讯场景}
\subsubsection{需求}
需要一种高效的消息通讯机制，可以用于点对点通讯或者创建聊天室等场景，以实现实时的消息传递和交流。

\subsubsection{设计}
设计一个基于消息队列的消息通讯系统，包括以下两种场景：
\begin{enumerate}
  \item 点对点通讯：客户端A和客户端B使用同一队列进行消息通讯；消息队列负责接收和转发客户端A和客户端B的消息。
  \item 客户端A、客户端B等多个客户端订阅同一主题：当有客户端发布消息时，消息队列将消息广播给所有订阅了该主题的客户端，客户端收到消息后进行展示。
\end{enumerate}

\section{常用消息队列框架}
\begin{enumerate}
  \item \textbf{RabbitMQ}：RabbitMQ 是一个开源的消息队列系统，实现了高级消息队列协议（AMQP），它是一个可靠、高可用、可扩展的消息代理。RabbitMQ 提供了多种消息传递模式，如点对点、发布/订阅等，适用于各种场景的应用程序。
  \item \textbf{RocketMQ}：RocketMQ 是阿里巴巴开源的分布式消息队列系统，具有高吞吐量、低延迟、高可用性等特点。它支持丰富的消息模型，包括顺序消息、事务消息等，适用于大规模分布式系统的消息通信。
  \item \textbf{Kafka}：Kafka 是由Apache软件基金会开发的分布式流处理平台和消息队列系统。Kafka 设计用于支持大规模的消息处理，具有高吞吐量、持久性、分区等特点，广泛应用于大数据领域。
  \item \textbf{ActiveMQ}：ActiveMQ 是一个开源的消息中间件，实现了 Java Message Service (JMS) 规范。它支持多种传输协议，如TCP、UDP、SSL等，提供了丰富的功能，包括消息持久化、事务支持等。
  \item \textbf{Amazon SQS}：Amazon SQS（Simple Queue Service）是亚马逊提供的消息队列服务，可帮助构建分布式应用程序。它具有高可用性、可扩展性、灵活性等特点，适用于构建在亚马逊云平台上的应用程序。
\end{enumerate}
本文将使用RabbitMQ。

\chapter{RocketMQ：启动}
\section{下载二进制文件包}
官网地址：https://rocketmq.apache.org/zh/docs/quickStart/01quickstart

获得二进制压缩包下载地址：\\https://dist.apache.org/repos/dist/release/rocketmq/5.1.4/rocketmq-all-5.1.4-bin-release.zip

使用wget命令下载压缩包：\\{\bfseries\kaishu wget https://dist.apache.org/repos/dist/release/rocketmq/5.1.4/rocketmq-all-5.1.4-bin-release.zip}
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/下载二进制文件.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{下载二进制压缩包}
    \label{fig:下载二进制压缩包}
  \end{minipage}
\end{center}

使用unzip命令解压二进制文件压缩包：\\{\bfseries\kaishu unzip rocketmq-all-5.1.4-bin-release.zip}
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=0.7\textwidth]{picture/解压二进制文件.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{解压二进制文件}
    \label{fig:解压二进制文件}
  \end{minipage}
\end{center}

\section{启动NameServer}
进入目录rocketmq-all-5.1.4-bin-release，执行命令：\\{\bfseries\kaishu nohup sh bin/mqnamesrv \&}

命令讲解：
\begin{itemize}
  \item {\bfseries\kaishu nohup：}这代表“不挂起”。在终端中执行命令然后关闭终端时，与该命令相关联的进程通常也会终止。nohup可以防止这种情况发生。
  \item sh：执行脚本文件的shell命令。
  \item bin/mqnamesrv：要运行的脚本路径。
  \item \&：后台运行。
\end{itemize}

发现运行失败：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/名字服务器启动失败.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{名字服务器启动失败}
    \label{fig:名字服务器启动失败}
  \end{minipage}
\end{center}

查看nohup.out文件，发现报错：{\bfseries\kaishu OpenJDK 64-Bit Server VM warning: INFO: \\os::commit\_memory(0x0000000700000000, 4294967296, 0) failed; error=\texttt{'}Not enough space\texttt{'} (errno=12)}

操作系统内存不足（由于RocketMQ对内存要求极高，所以自己用云服务器运行基本都会报错），进行修改：

进入rocketmq-all-5.1.4-bin-release/bin目录，对runserver.sh 和 runbroker.sh 以及 tools.sh进行修改。（可使用vim的/+关键字进行查找）
\begin{enumerate}
  \item runserver.sh：
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m 
  \\-XX:MaxMetaspaceSize=320m\texttt{"}}
  \\替换为
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms256m -Xmx256m -Xmn128m 
  \\-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\texttt{"}}
  \\注意有两处。
  \item runbroker.sh：
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms8g -Xmx8g\texttt{"}}
  \\替换为{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms256m -Xmx256m\texttt{"}}，
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -Xmn8G -XX:+UseConcMarkSweepGC }
  \\替换为
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -Xmn256m -XX:+UseConcMarkSweepGC }
  \item tools.sh：
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms1g -Xmx1g -Xmn256m -XX:MetaspaceSize=128m 
  \\-XX:MaxMetaspaceSize=128m\texttt{"}}
  \\替换为
  \\{\bfseries\kaishu JAVA\_OPT=\texttt{"}\${JAVA\_OPT} -server -Xms256m -Xmx256m -Xmn128m 
  \\-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m\texttt{"}}。
\end{enumerate}

再次输入命令：{\bfseries\kaishu nohup sh bin/mqnamesrv \&}

未报错，查看nohup.out文件，发现启动成功：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/名称服务器启动成功.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{名称服务器启动成功}
    \label{fig:名称服务器启动成功}
  \end{minipage}
\end{center}

\section{启动Broker+Proxy}
执行命令：\\{\bfseries\kaishu nohup sh bin/mqbroker -n localhost:9876 -{}-enable-proxy \&}

可使用命令来查看是否启动成功：{\bfseries\kaishu tail\  -f\ \textasciitilde/logs/rocketmqlogs/proxy.log}

未报错，查看nohup.out文件，发现启动还是失败：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/broker启动失败.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{broker启动失败}
    \label{fig:broker启动失败}
  \end{minipage}
\end{center}

原因是JAVA版本过高，进行修复。

修改runbroker.sh文件：

在{\bfseries\kaishu numactl --interleave=all pwd > /dev/null 2>\&1}上方添加

{\bfseries\kaishu \$JAVA \${JAVA\_OPT} {-}{-}add-exports=java.base/sun.nio.ch=ALL-UNNAMED \$@}


然后再次运行{\bfseries\kaishu nohup sh bin/mqbroker -n localhost:9876 –enable-proxy \&}

并查看nohup.out，发现为不断更新的日志文件，推测运行成功。

查看/root/logs/rocketmqlogs，发现运行成功。
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/broker启动成功.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{broker启动成功}
    \label{fig:broker启动成功}namesrv
  \end{minipage}
\end{center}

至此，RocketMQ启动成功。

\section{关闭服务器}
先关闭消息队列：
{\bfseries\kaishu sh\  bin/mqshutdown\  broker}

再关闭名称服务：
{\bfseries\kaishu sh\  bin/mqshutdown\  namesrv}

\chapter{领域模型}
\section{架构总览}
组件示意图：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/RocketMQ全局图.jpg}
    \captionsetup{hypcap=false}
    \captionof{figure}{RocketMQ全局图}
    \label{fig:RocketMQ全局图}
  \end{minipage}
\end{center}

\begin{itemize}
  \item {\bfseries\kaishu Producer：}消息生产者。
  \item {\bfseries\kaishu NameSrv：}名称服务，即路由注册中心，可记录中转者提供给消费者和生产者。
  \item {\bfseries\kaishu Broker：}中转者（也可以认为是队列Queen），负责接受、存储、转发消息。
  \item {\bfseries\kaishu Comsumer：}消息消费者。
  \item Producer group：生产者组。
  \item Comsumer group：消费者组。
  \item Broker cluster：中转者集群。
\end{itemize}

\section{基本概念}

\subsection{消息的生命周期}
RocketMQ 中消息的生命周期主要分为{\bfseries\kaishu 消息生产、消息存储、消息消费}这三部分。

生产者生产消息并发送至RocketMQ 服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。

\subsubsection{消息生产}
\textbf{生产者（Producer）：}
在RocketMQ中，生产者是用来发送消息的组件，通常它被集成到业务系统的前端。生产者是轻量级匿名无身份的。

\subsubsection{消息存储}
\textbf{消息（Message）：}
RocketMQ 的最小传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变。

\textbf{主题（Topic）：}
RocketMQ 消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。

\textbf{队列（MessageQueue）：}
RocketMQ 消息传输和存储的实际单元容器，类比于其他消息队列中的分区。 RocketMQ 使用流式特性的无限队列结构来存储消息，消息在队列内会按顺序进行存储。

\subsubsection{消息消费}
\textbf{消费者分组（ConsumerGroup）：}
RocketMQ 发布订阅模型中定义的独立的消费身份分组，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持消费逻辑和配置一致，共同分担该消费组订阅的消息，实现消费能力的水平扩展。

\textbf{消费者（Consumer）：}
RocketMQ 消费消息的运行实体，通常它被集成到业务系统的后端。消费者必须被指定到某一个消费组中。

\textbf{订阅关系（Subscription）：}
RocketMQ 的订阅关系是指在发布订阅模型中，用于配置消息过滤、重试以及消费进度的规则。订阅关系是以消费组为单位进行管理的，消费组通过定义订阅关系来控制该组下的消费者如何处理消息的过滤、重试以及消费进度恢复等操作。
简单来说，订阅关系就是消费组对消息的一种规则设定，可以让我们更加灵活地控制消息的处理方式，确保系统能够按照我们预期的方式来消费和处理消息。\\
\begin{ignore}
  RocketMQ 的订阅关系除过滤表达式之外都是持久化的，即服务端重启或请求断开，订阅关系依然保留。
\end{ignore}

\subsection{通信方式}
分布式系统架构思想下，将复杂系统拆分为多个独立的子模块，例如微服务模块。此时就需要考虑子模块间的远程通信，典型的通信模式分为以下两种，一种是{\bfseries\kaishu 同步的RPC远程调用}；一种是{\bfseries\kaishu 基于中间件代理的异步通信}。

\subsubsection{同步RPC调用模型}
同步RPC调用模型下，不同系统之间直接进行调用通信，每个请求直接从调用方发送到被调用方，然后要求被调用方立即返回响应结果给调用方，以确定本次调用结果是否成功。\\
\begin{ignore}
  注意：此处的同步并不代表RPC的编程接口方式，RPC也可以有异步非阻塞调用的编程方式，但本质上仍然是需要在指定时间内得到目标端的直接响应。
\end{ignore}

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/同步RPC调用模型.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{同步RPC调用模型}
    \label{fig:同步RPC调用模型}
  \end{minipage}
\end{center}

\subsubsection{异步通信模型}
异步消息通信模式下，各子系统之间无需强耦合直接连接，调用方只需要将请求转化成异步事件（消息）发送给中间代理，发送成功即可认为该异步链路调用完成，剩下的工作中间代理会负责将事件可靠通知到下游的调用系统，确保任务执行完成。该中间代理一般就是消息中间件。

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/异步通信模型.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{异步通信模型}
    \label{fig:异步通信模型}
  \end{minipage}
\end{center}

异步通信优势如下：
\begin{enumerate}
  \item 星型结构系统，拓扑简单，易于维护和管理。
  \item 上下游耦合性弱，可以独立升级和变更，不会互相影响。
  \item 容量削峰填谷。基于消息的中间代理往往具备很强的流量缓冲和整形能力，业务流量高峰到来时不会击垮下游。
\end{enumerate}

\subsection{消息传输模型}
主流的消息中间件的传输模型主要为{\bfseries\kaishu 点对点模型}和{\bfseries\kaishu 发布订阅模型}。
\subsubsection{点对点模型}
点对点模型也叫队列模型，具有如下特点：
\begin{enumerate}
  \item 消费匿名：消息上下游沟通的唯一的身份就是队列，下游消费者从队列获取消息无法申明独立身份（即中间件对同一个队列中的所有消费者都一视同仁）。
  \item 一对一通信：基于消费匿名特点，下游消费者即使有多个，但都没有自己独立的身份，因此共享队列中的消息，每一条消息都只会被唯一一个消费者处理。因此点对点模型只能实现一对一通信。
\end{enumerate}

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/点对点模型.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{点对点模型}
    \label{fig:点对点模型}
  \end{minipage}
\end{center}

\subsubsection{发布订阅模型}
发布订阅模型具有如下特点：
\begin{enumerate}
  \item 消费独立：相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。
  \item 一对多通信：基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。
\end{enumerate}

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/发布订阅模型.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{发布订阅模型}
    \label{fig:发布订阅模型}
  \end{minipage}
\end{center}

\subsubsection{对比}
点对点模型和发布订阅模型各有优势，点对点模型更为简单，而发布订阅模型的扩展性更高。RocketMQ 使用的传输模型为发布订阅模型，因此也具有发布订阅模型的特点。

\section*{领域模型图}
领域模型图：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/领域模型图.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{领域模型图}
    \label{fig:领域模型图}
  \end{minipage}
\end{center}
\section{主题（Topic）}
主题是 RocketMQ 中消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息。
主题的作用主要如下：
\begin{enumerate}
  \item {\bfseries\kaishu 数据分类}：在 RocketMQ 的方案设计中，建议将不同业务类型的数据拆分到不同的主题中管理，通过主题实现存储的隔离性和订阅隔离性。
  \item {\bfseries\kaishu 区分身份和权限}：RocketMQ 的消息本身是匿名无身份的，同一分类的消息使用相同的主题来做身份识别和权限管理。
\end{enumerate}

\subsection{模型关系：主题}
在整个RocketMQ领域模型中，主题所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：主题}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：主题}
    \label{fig:模型关系：主题}
  \end{minipage}
\end{center}

主题是 RocketMQ 的顶层存储，所有消息资源的定义都在主题内部完成，但主题是一个{\bfseries\kaishu 逻辑概念}，并不是实际的消息容器。

\textbf{主题内部由多个队列组成，消息的存储和水平扩展能力最终是由队列实现的；并且针对主题的所有约束和属性设置，最终也是通过主题内部的队列来实现。}

\subsection{内部属性}
\begin{enumerate}
  \item \textbf{主题名称}：主题的名称，用于标识主题，主题名称集群内全局唯一，由用户创建主题时定义。
  \item \textbf{队列列表}：队列作为主题的组成单元，是消息存储的实际容器，一个主题内包含一个或多个队列，消息实际存储在主题的各队列内；队列数量创建主题时定义（一个主题内至少包含一个队列）。
  \item \textbf{消息类型}：主题所支持的消息类型（包括普通消息、顺序消息、定时/延时消息、事务消息），每个主题只允许发送一种消息类型的消息。
\end{enumerate}

\subsection{Admin工具相关操作}
创建主题操作命令：\\
\textbf{sh mqadmin updateTopic -n <nameserver\_address> -t <topic\_name> -c <cluster\_name> -a +message.type=<message\_type>}

各类操作（详情见\href{https://rocketmq.apache.org/zh/docs/deploymentOperations/02admintool}{RocketMQ官网}）：
\begin{enumerate}
  \item updateTopic：创建/更新Topic配置。
  \item deleteTopic：删除Topic。
  \item topicList：查看 Topic 列表信息。
  \item topicRoute：查看 Topic 路由信息。
  \item topicStatus：查看 Topic 消息队列offset。
  \item topicClusterList：查看 Topic 所在集群列表。
  \item updateTopicPerm：更新 Topic 读写权限。
  \item updateOrderConf：以平均负载算法计算消费者列表负载消息队列的负载结果。
  \item statsAll：打印Topic订阅关系、TPS、积累量、24h读写总量等信息。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 合理拆分主题，注意消息量级与消息时效性，避免将时效性要求高的业务消息与量级大的业务消息归到同一主题。
  \item 单一主题只收发一种类型消息，避免混用。
  \item 主题管理尽量避免自动化机制，并在生产环境需保证严格管理主题资源，不随意进行增、删、改、查操作。
\end{itemize}

\section{队列（MessageQueue）}
队列是 RocketMQ 中{\bfseries\kaishu 消息存储和传输的实际容器}，也是 RocketMQ 消息的最小存储单元。

RocketMQ 的所有主题都是由多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。

队列的作用如下：
\begin{enumerate}
  \item 存储顺序性：队列天然具备顺序性，即消息按照进入队列的顺序写入存储。消息在队列中的位置通过位点（Offset）进行记录，队列头部为最早写入的消息（Offset=0），队列尾部为最新写入的消息（Offset逐渐递增）。
  \item 流式操作语义：RocketMQ 基于队列的存储模型可确保消息从任意位点（Offset）读取任意数量的消息，以此实现类似聚合读取、回溯读取等特性，这些特性是队列存储模型特有的。
\end{enumerate}

\subsection{模型关系：队列}
在整个RocketMQ领域模型中，队列所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：队列.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：队列}
    \label{fig:模型关系：队列}
  \end{minipage}
\end{center}

RocketMQ 默认提供{\bfseries\kaishu 可靠的消息存储机制}，所有发送成功的消息都被持久化存储到队列中，配合生产者和消费者客户端的调用保证至少投递一次。

\textbf{队列属于主题的一部分，虽然所有的消息资源以主题粒度管理，但实际的操作实现是面向队列。}例如，生产者指定某个主题，向主题内发送消息，但实际消息发送到该主题下的某个队列中。

RocketMQ 中可通过修改队列数量，以此实现横向的水平扩容和缩容。

\subsection{内部属性}
\begin{enumerate}
  \item 读写权限：当前队列是否可以读写数据（队列的读写权限属于运维侧操作，不建议频繁修改）。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 队列数量的设置应遵循少用够用原则，否则可能导致集群元数据膨胀、系统负荷增加（队列越多，消费者的轮询越多）。
  \item 在集群水平扩容增加节点后，为了保证集群流量的负载均衡，建议在新的服务节点上新增队列，或将旧的队列迁移到新的服务节点上。
  \item 顺序消息的并发度会在一定程度上受队列数量的影响，当达到性能瓶颈时需要再增加队列。
\end{itemize}

\section{消息（Message）}
消息是RocketMQ 中的{\bfseries\kaishu 最小数据传输单元}。
生产者将业务数据的负载和拓展属性包装成消息发送到 RocketMQ 服务端，服务端按照相关语义将消息投递到消费端进行消费。

消息的特点：
\begin{enumerate}
  \item 不可变性：一旦产生后，消息的内容不会发生改变；消费端获取的消息都是只读消息视图。
  \item 持久化：RocketMQ 会默认对消息进行持久化，即将接收到的消息存储到 RocketMQ 服务端的存储文件中，保证消息的可回溯性和系统故障场景下的可恢复性。
\end{enumerate}

\subsection{模型关系：消息}
在整个 RocketMQ 领域模型中，消息所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：消息.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：消息}
    \label{fig:模型关系：消息}
  \end{minipage}
\end{center}

消息由生产者初始化并发送到 RocketMQ 服务端，并按照到达 RocketMQ 服务端的顺序存储到队列中。消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费。

\subsection{内部属性}
\begin{enumerate}
  \item 主题名称：当前消息所属的主题的名称。
  \item 消息队列：实际存储当前消息的队列。
  \item 消息位点：当前消息存储在队列中的位置（Offset）。
  \item 消息ID：消息的唯一标识，集群内每条消息的ID全局唯一，自动生成的32位字符串。
  \item 消息类型：当前消息的类型，分为Normal（普通消息）、FIFO（顺序消息）、Delay（定时消息）、Transaction（事务消息）。
  \item 消息负载：业务消息的实际报文数据，由生产者负责序列化编码，按照二进制字节传输。
  \item 消息发送时间戳：消息发送时，生产者客户端系统的本地毫秒级时间戳。
  \item 消息保存时间戳：消息在 RocketMQ 服务端完成存储时，服务端系统的本地毫秒级时间戳。
  \item 消费重试次数：消息消费失败后， RocketMQ 服务端重新投递的次数。每次重试后，重试次数加1。
  \item 其他自定义属性。
  \item 索引Key列表（可选）：消息的索引键，可通过设置不同的Key区分消息和快速查找消息，由生产者定义。
  \item 过滤标签Tag（可选）：消息的过滤标签。消费者可通过Tag对消息进行过滤，仅接收指定标签的消息，由生产者定义。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 单条消息不建议传输超大负载。
  \item 由于消息的不可变性，在使用过程中对消息进行中转操作时，需要对消息重新初始化。
\end{itemize}

\section{生产者（Producer）}
生产者是 RocketMQ 系统中用来构建并传输消息到 RocketMQ 服务端的运行实体，生产者是匿名的。

在消息生产者中，可以定义如下传输行为：
\begin{enumerate}
  \item 发送方式：生产者可通过API接口设置消息发送的方式，支持同步传输和异步传输。
  \item 批量发送：生产者可通过API接口设置消息批量传输的方式。例如，批量发送的消息条数或消息大小。
  \item 事务行为：Apache RocketMQ 支持事务消息，对于事务消息需要生产者配合进行事务检查等行为保障事务的最终一致性。
\end{enumerate}

生产者和主题的关系为{\bfseries\kaishu 多对多关系}，即同一个生产者可以向多个主题发送消息，对于平台类场景如果需要发送消息到多个主题，并不需要创建多个生产者；同一个主题也可以接收多个生产者的消息，以此可以实现生产者性能的水平扩展和容灾。

\subsection{模型关系：生产者}
在整个 RocketMQ 领域模型中，生产者所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：生产者.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：生产者}
    \label{fig:模型关系：生产者}
  \end{minipage}
\end{center}

消息由生产者初始化并发送到RocketMQ 服务端。

\subsection{内部属性}
\begin{enumerate}
  \item 生产者客户端ID：生产者客户端的标识，用于区分不同的生产者。集群内全局唯一。
  \item 通信参数：接入点信息（必选，连接服务端的接入地址，用于识别服务端集群）、身份认证信息 （可选）、请求超时时间 （可选）。
  \item 发送重试策略；生产者在消息发送失败时的重试策略。
  \item 预绑定主题列表：生产者需要将消息发送到的目标主题列表。服务端会在生产者初始化时根据预绑定主题列表，检查目标主题的访问权限和合法性，而不需要等到应用启动后再检查。事务消息场景下，生产者在故障、重启恢复时，需要检查事务消息的主题中是否有未提交的事务消息，因此必须设置。
  \item 事务检查器：事务消息场景下，生产者需要主动实现事务检查器的接口，以保证异常场景下事务的最终一致性。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。
  \item 生产者是可以重复利用的底层资源，类似数据库的连接池中的连接一样，不建议频繁创建和销毁。
\end{itemize}

\section{消费者分组（ConsumerGroup）}
消费者分组是 RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组，并可通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。
和消费者不同，消费者分组并不是运行实体，而是一个{\bfseries\kaishu 逻辑资源}。

同一分组下的多个消费者将\textbf{按照分组内统一的消费行为和负载均衡策略}消费消息，包含以下消费行为：
\begin{enumerate}
  \item 订阅关系：RocketMQ 以消费者分组的粒度管理订阅关系。
  \item 投递顺序性：RocketMQ 的服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。
  \item 消费重试策略：消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。
\end{enumerate}

\subsection{模型关系：消费者分组}
在整个 RocketMQ 领域模型中，消费者分组所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：消费者分组.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：消费者分组}
    \label{fig:模型关系：消费者分组}
  \end{minipage}
\end{center}

消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费。

\subsection{内部属性}
\begin{enumerate}
  \item 消费者分组名称：消费者分组的名称，用于区分不同的消费者分组。集群内全局唯一。
  \item 订阅关系：当前消费者分组关联的订阅关系集合。包括消费者订阅的主题，以及消息的过滤规则等。订阅关系由消费者动态注册到消费者分组中，RocketMQ 服务端会持久化订阅关系并匹配消息的消费进度。
  \item 投递顺序性：消费者消费消息时，RocketMQ 向消费者客户端投递消息的顺序（支持顺序投递和并发投递）。
  \item 消费重试策略：消费者消费消息失败时，系统的重试策略（将特定消息投递给消费者重新消费）。包括最大重试次数（超过则放入死信队列）、重试间隔。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 按照业务合理拆分分组。
  \item 消费者分组管理尽量避免自动化机制，请勿随意进行增、删、改、查操作。
\end{itemize}

\section{消费者（Consumer）}
消费者是 RocketMQ 中用来接收并处理消息的运行实体。
消费者通常被集成在业务系统中，从 RocketMQ 服务端获取消息，并将消息转化成业务可理解的信息，供业务逻辑处理。

在消息消费端，可以定义如下传输行为：
\begin{enumerate}
  \item 消费者身份：消费者必须关联一个指定的消费者分组，以获取分组内统一定义的行为配置和消费状态。
  \item 消费者类型：RocketMQ 面向不同的开发场景提供了多样的消费者类型，包括PushConsumer类型、SimpleConsumer类型、PullConsumer类型（仅推荐流处理场景使用）等。
  \item 消费者本地运行配置：消费者根据不同的消费者类型，控制消费者客户端本地的运行配置。例如消费者客户端的线程数，消费并发度等，实现不同的传输效果。
\end{enumerate}

\subsection{模型关系：消费者}
在整个 RocketMQ 领域模型中，消费者所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：消费者.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：消费者}
    \label{fig:模型关系：消费者}
  \end{minipage}
\end{center}

消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费。

\subsection{内部属性}
\begin{enumerate}
  \item 客户端ID：消费者客户端的标识，用于区分不同的消费者。集群内全局唯一。
  \item 消费者分组名称：当前消费者关联的消费者分组名称，消费者必须关联到指定的消费者分组，\textbf{通过消费者分组获取消费行为}。
  \item 预绑定订阅关系列表：指定消费者的订阅关系列表。RocketMQ 服务端可在消费者初始化阶段，根据预绑定的订阅关系列表对目标主题进行权限及合法性校验，无需等到应用启动后才能校验。
  \item 通信参数：接入点信息（必选）、身份认证信息（可选）、请求超时时间（可选）。
  \item 消费监听器：获得RocketMQ服务端的消息后，消费者调用消息消费逻辑的监听器。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 消费者是可以重复利用的底层资源，类似数据库的连接池中的连接一样，不建议频繁创建和销毁。
  \item 由于消费者在通信协议层面支持非阻塞传输模式，大部分场景下，单台主机内的一个消费分组只需要初始化一个唯一的消费者即可。
\end{itemize}

\section{订阅关系（Subscription）}
订阅关系是 RocketMQ 系统中消费者获取消息、处理消息的规则和状态配置。
订阅关系由消费者分组动态注册到服务端系统，并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护。

通过配置订阅关系，可控制如下传输行为：
\begin{enumerate}
  \item 消息过滤规则：用于控制消费者在消费消息时，选择主题内的哪些消息进行消费，设置消费过滤规则可以高效地过滤消费者需要的消息集合，灵活根据不同的业务场景设置不同的消息接收范围。
  \item 消费状态：Apache RocketMQ 服务端默认提供订阅关系持久化的能力，即消费者分组在服务端注册订阅关系后，当消费者离线并再次上线后，可以获取离线前的消费进度并继续消费。
\end{enumerate}

\subsection{模型关系：订阅关系}
在整个 RocketMQ 领域模型中，订阅关系所处的位置如下（橙色区域）：

\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/模型关系：订阅关系.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{模型关系：订阅关系}
    \label{fig:模型关系：订阅关系}
  \end{minipage}
\end{center}

消费者按照指定的订阅关系从 RocketMQ 服务端中获取消息并消费。

\subsection{订阅关系判断原则}
RocketMQ 的订阅关系{\bfseries\kaishu 按照消费者分组和主题粒度}设计，因此，一个订阅关系指的是指定某个消费者分组对于某个主题的订阅。

判断原则如下：
\subsubsection{不同消费者分组对于同一个主题的订阅}
不同消费者分组对于同一个主题的订阅是相互独立的。如图：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/不同消费者分组对于同一个主题的订阅相互独立.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{不同消费者分组对于同一个主题的订阅}
    \label{fig:不同消费者分组对于同一个主题的订阅}
  \end{minipage}
\end{center}

消费者分组Group A和消费者分组Group B分别以不同的订阅关系订阅了同一个主题Topic A，这两个订阅关系互相独立，可以各自定义，不受影响。

\subsubsection{同一个消费者分组对于不同主题的订阅}
同一个消费者分组对于不同主题的订阅也是相互独立的。如图：
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/同一个消费者分组对于不同主题的订阅.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{同一个消费者分组对于不同主题的订阅}
    \label{fig:同一个消费者分组对于不同主题的订阅}
  \end{minipage}
\end{center}

消费者分组Group A订阅了两个主题Topic A和Topic B，对于Group A中的消费者来说，订阅的Topic A为一个订阅关系，订阅的Topic B为另外一个订阅关系，且这两个订阅关系互相独立，可以各自定义，不受影响。

\subsection{内部属性}
\begin{enumerate}
  \item 过滤类型：消息过滤规则的类型，分为TAG过滤（对Tag字符串进行全文过滤匹配）和SQL92过滤（按照SQL语法对消息属性进行过滤匹配）。
  \item 过滤表达式：自定义的过滤规则表达式。
\end{enumerate}

\subsection{使用建议}
\begin{itemize}
  \item 不要频繁修改订阅关系，这样可能会导致客户端一直处于负载均衡调整和变更的过程，从而影响消息接收。
\end{itemize}

\chapter{Springboot快速集成RocketMQ}
资料来源：\\
\href{https://github.com/apache/rocketmq-spring/wiki}{rocketmq-spring的Github地址}\\
\href{https://blog.csdn.net/qq_36737803/article/details/112261352}{CSDN上的一篇优质介绍文章}

\section{添加Maven依赖}
作者使用的版本是2.2.2，也可以直接看\href{https://mvnrepository.com/artifact/org.apache.rocketmq}{rocketmq-spring-boot-starter的Maven仓库}来获得最新版本。

\begin{xml}[caption=Maven依赖]
<dependency>
  <groupId>org.apache.rocketmq</groupId>
  <artifactId>rocketmq-spring-boot-starter</artifactId>
  <version>2.2.2</version>
</dependency>
\end{xml}

\section{添加配置文件属性}
\begin{yaml}[caption=配置文件application.yml]
rocketmq:
  name-server: 192.168.146.132:9876 # 名称服务访问地址
  producer:
    group: TEST_GROUP # 必须指定group
    send-message-timeout: 3000 # 消息发送超时时长，默认3s
    retry-times-when-send-failed: 3 # 同步发送消息失败重试次数，默认2
    retry-times-when-send-async-failed: 3 # 异步发送消息失败重试次数，默认2
\end{yaml}

\section{生产者}
\subsection{普通消息}
需要先注入RocketMQTemplate的Bean，用于进行消息的发送;
topic用于指定发送消息到的主题，sendMessage为发送的具体消息;
可使用topic:tag的格式附带消息的Tag;
可使用setHeader方法来设置消息的key。

\subsubsection{同步发送}
阻塞当前线程，等待broker响应发送结果。
\begin{java}[caption=普通消息同步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public SendResult syncSend(Object sendMessage,String topic,String tag,String key) {
  return rocketMQTemplate.syncSend(topic+":"+tag, MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build());
}
\end{java}
\begin{java}[caption=同步发送方式简化版]
@Resource
private RocketMQTemplate rocketMQTemplate;
public SendResult syncSend(Object sendMessage,String topic) {
  return rocketMQTemplate.syncSend(topic, MessageBuilder.withPayload(sendMessage).build());
}
\end{java}

\subsubsection{异步发送}
通过线程池执行发送到broker的消息任务，执行完后回调：在SendCallback中可处理相关成功失败时的逻辑。
\begin{java}[caption=普通消息异步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public void asyncSend(Object sendMessage, String topic, String tag, String key) {
  rocketMQTemplate.asyncSend(topic + ":" + tag, MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build(), new SendCallback() {
    @Override
    public void onSuccess(SendResult sendResult) {
      //发送异步消息成功后的处理...
    }

    @Override
    public void onException(Throwable throwable) {
      //发送异步消息失败后的处理...
    }
  });
}
\end{java}

\subsubsection{单向发送}
只负责发送消息，不等待应答，不关心发送结果。
\begin{java}[caption=普通消息单向发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public void oneWaySend(Object sendMessage,String topic,String tag,String key) {
  rocketMQTemplate.sendOneWay(topic+":"+tag, MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build());
}
\end{java}

\subsection{顺序消息}
topic必须为顺序类型的主题，不允许将消息放到不同类型的主题。hashkey用于确定发送到同一个主题中的哪个队列。要求顺序消费的多个消息必须使用同一个hashkey以保证进入同一个队列。
\subsubsection{同步发送}
\begin{java}[caption=顺序消息同步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public SendResult syncOrderlySend(Object sendMessage,String topic,String tag,String key,String hashkey) {
  return rocketMQTemplate.syncSendOrderly(topic+":"+tag,MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build(),hashkey);
}
\end{java}
\subsubsection{异步发送}
\begin{java}[caption=顺序消息异步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public void asyncOrderlySend(Object sendMessage,String topic,String tag,String key,String hashkey) {
  rocketMQTemplate.asyncSendOrderly(topic+":"+tag,MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build(),hashkey,new SendCallback() {
    @Override
    public void onSuccess(SendResult sendResult) {
      System.out.println("发送异步消息成功" + JSON.toJSONString(sendResult));
      //发送异步消息成功后的处理...
    }

    @Override
    public void onException(Throwable throwable) {
      System.out.println("发送异步消息失败" + JSON.toJSONString(throwable));
      //发送异步消息失败后的处理...
    }
  });
}
\end{java}

\subsection{延迟消息}
延迟消息就是普通消息发送的后面加上一个timeout属性和delayLevel属性。
timeout是消息发送超时时长，为默认3s。
delayLevel属性分为18个等级，分别为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。
\subsubsection{同步发送}
\begin{java}[caption=延迟消息同步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public SendResult syncDelaySend(Object sendMessage,String topic,String tag,String key,long timeout, int delayLevel) {
  return rocketMQTemplate.syncSend(topic+":"+tag,MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build(),timeout,delayLevel);
}
\end{java}

\subsubsection{异步发送}
\begin{java}[caption=延迟消息异步发送方式]
@Resource
private RocketMQTemplate rocketMQTemplate;
public void asyncDelaySend(Object sendMessage, String topic, String tag, String key, long timeout, int delayLevel) {
  rocketMQTemplate.asyncSend(topic + ":" + tag, MessageBuilder.withPayload(sendMessage).setHeader(RocketMQHeaders.KEYS, key).build(), new SendCallback() {
    @Override
    public void onSuccess(SendResult sendResult) {
      System.out.println("发送异步消息成功" + JSON.toJSONString(sendResult));
      //发送异步消息成功后的处理...
    }

    @Override
    public void onException(Throwable throwable) {
      System.out.println("发送异步消息失败" + JSON.toJSONString(throwable));
      //发送异步消息失败后的处理...
    }
  }, timeout, delayLevel);
}
\end{java}

\subsection{批量消息}
批量消息的发送方式即将原先普通消息中的sendMessage换成Collection<Message>的对象即可。
\subsubsection{同步发送}

\begin{java}[caption=批量消息同步发送方式（简化版）]
@Resource
private RocketMQTemplate rocketMQTemplate;
public void syncBatchSend(List<Object> sendMessage, String topic) {
  ArrayList<Message<Object>> list = new ArrayList<>();
  for (Object message : sendMessage) {
    list.add(MessageBuilder.withPayload(message).build());
  }
  rocketMQTemplate.syncSend(topic, list);
}
\end{java}

复杂版本和异步版本省略。
\subsection{事务消息}
还不会。

\section{消费者}
在RocketMQMessageListener注解中，topic用于指定接收的主题，selectorType用于指定过滤的方式（默认为Tag，可更改为SQL92），selectorExpression用于控制消息的过滤规则（Tag模式下，*代表全部Tag），consumeMode用于指定是即时接收消息还是顺序接收消息。
（其他注解属性请自行了解）
\subsection{Push模式}
消费消息仅通过消费监听器处理业务并返回消费结果。消息的获取、消费状态提交以及消费重试都通过 Apache RocketMQ 的客户端SDK完成。
\begin{java}[caption=Push模式消费者]
@Service
@RocketMQMessageListener(topic = "TEST_TOPIC", selectorExpression = "test", consumerGroup = "Group_One")
public class ConsumerSend implements RocketMQListener<User> {
  // 监听到消息就会执行此方法
  @Override
  public void onMessage(Object message) {
    //此处为处理消息的方法
  }
}
\end{java}

\subsection{Pull模式}
如果使用Pull模型，需要补充配置文件属性。（注意：如果不使用，就不要添加该属性。）

\begin{yaml}[caption=lite pull consumer所需配置属性]
rocketmq.pull-consumer.group=Group_One
rocketmq.pull-consumer.topic=TEST_TOPIC
\end{yaml}

Pull模型通过调用RocketMQTemplate的receive方法实现。
\begin{java}[caption=Pull模式消费者]
public void Pull() throws Exception {
  List<Object> messages = rocketMQTemplate.receive(Object.class);
  //此处处理接收到的message集合
}
\end{java}

\chapter{功能特性}
\section{四类消息}
\subsection{普通消息}
普通消息是RocketMQ中最基础的消息。常用于微服务解耦、数据集成\footnote{在不同系统、应用程序或数据存储之间传输、转换、共享和同步数据的情况}等场景。

\subsubsection{普通消息的生命周期}
\begin{enumerate}
  \item 初始化：消息被生产者构建并完成初始化，{\bfseries\kaishu 待发送到服务端}的状态。
  \item 待消费：消息{\bfseries\kaishu 被发送到服务端}，对消费者可见，等待消费者消费的状态。
  \item 消费中：消息{\bfseries\kaishu 被消费者获取}，并按照消费者本地的业务逻辑进行处理的过程。 
  \item 消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前{\bfseries\kaishu 消息已经被处理}（包括消费成功和失败）。
  \item 消息删除：RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。
\end{enumerate}

\subsubsection{使用方式}
\begin{itemize}
  \item 在broker中先提前创建NORMAL类型的消息主题：
  \begin{bash}
    sh mqadmin updateTopic -n <nameserver_address> -t <topic_name> -c <cluster_name> -a +message.type=NORMAL
  \end{bash}
  \item 在客户端SDK中向该主题发送消息即可。
\end{itemize}

\subsection{定时/延时消息}
定时/延时消息为RocketMQ 中的高级特性消息。常用于分布式定时调度\footnote{如每天5点执行文件清理}、任务超时处理\footnote{订单下单后暂未支付，需要等待一段时间后关闭订单}等场景。

RocketMQ 定时消息设置的定时时间是一个预期触发的系统时间戳，延时时间也需要转换成当前系统时间后的某一个时间戳，而不是一段延时时长，
定时时间的格式为毫秒级的Unix时间戳。

社区版的定时消息支持18个等级的延迟：
\begin{center}
  \begin{minipage}{\textwidth}
    \centering % 居中对齐
    \begin{tabular}{|c|c|c|c|} % c=居中对齐列，列之间用竖线分隔
      \hline % 画水平线
      \textbf{延迟等级} & \textbf{延迟时间} & \textbf{延迟等级} & \textbf{延迟时间} \\
      \hline
      1 & 1s & 10 & 6min \\
      2 & 5s & 11 & 7min \\
      3 & 15s & 12 & 8min \\
      4 & 30s & 13 & 9min \\
      5 & 1min & 14 & 10min \\
      6 & 2min & 15 & 20min \\
      7 & 3min & 16 & 30min \\
      8 & 4min & 17 & 1h \\
      9 & 5min & 18 & 2h \\
      \hline
    \end{tabular}
    \captionsetup{hypcap=false}
    \captionof{table}{18个等级的延迟}
    \label{tab:18个等级的延迟} % 用于交叉引用的标签
  \end{minipage}
\end{center}

\subsection{延时消息的生命周期}
\begin{enumerate}
  \item 初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。
  \item {\bfseries\kaishu 定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达。}
  \item 待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。
  \item 消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。
  \item 消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。
  \item 消息删除：RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。
\end{enumerate}

\subsubsection{使用方式}
\begin{enumerate}
  \item 使用mqadmin工具创建延迟类型的主题：
  \begin{bash}
    sh mqadmin updateTopic -n <nameserver_address> -t <topic_name> -c <cluster_name> -a +message.type=DELAY
  \end{bash}
\end{enumerate}

\subsection{顺序消息}
顺序消息为RocketMQ 中的高级特性消息，常用于有序事件处理、数据库变更增量同步\footnote{如数据库操作日志，不可乱序}等场景。

\subsubsection{保证顺序性}
为保证顺序性，需同时保证生产顺序性和消费顺序性。
\begin{itemize}
  \item 保证消息生产的顺序性，必须满足单一生产者、串行发送两个条件。
  \begin{itemize}
    \item 单一生产者：消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的消息组，不同生产者之间产生的消息也无法判定其先后顺序。
    \item 串行发送：生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法保证先后顺序。
  \end{itemize}
  \item 保证消息消费的顺序性，必须满足投递顺序、有限重试两个条件。
  \begin{itemize}
    \item 投递顺序：RocketMQ 通过客户端SDK和服务端通信协议保障消息按照服务端存储顺序投递，但业务方消费消息时需要严格按照接收---处理---应答的语义处理消息，避免因异步处理导致消息乱序。
    \item 有限重试：生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法保证先后顺序。\footnote{如果设置的重试次数过大，当消息消费失败时会进行多次重试，导致消息消费的延迟。如果后续消息的处理速度快于重试消息的消费速度，可能会导致后续消息先于重试消息被消费，从而导致消息乱序。}
  \end{itemize}
\end{itemize}

服务端顺序存储逻辑如下：
相同消息组的消息按照先后顺序被存储在同一个队列；
不同消息组的消息可以混合在同一个队列中，且不保证连续。
\begin{center}
  \begin{minipage}{\textwidth}
    \center
    \includegraphics[width=\textwidth]{picture/服务端顺序存储逻辑.png}
    \captionsetup{hypcap=false}
    \captionof{figure}{服务端顺序存储逻辑}
    \label{fig:服务端顺序存储逻辑}
  \end{minipage}
\end{center}
如上图所示，同组的消息均保证顺序。

\subsubsection{顺序消息生命周期}
顺序消息生命周期与普通消息生命周期相同。

\subsubsection{使用方式}
\begin{enumerate}
  \item 使用mqadmin工具创建顺序消息类型的主题：
  \begin{bash}
    sh mqadmin updateTopic -n <nameserver_address> -t <topic_name> -c <cluster_name> -a +message.type=FIFO
  \end{bash}
  \item 发送消息时需要设置MessageGroup，该值用于为消息设置 GroupID，同一个 GroupID 的消息只会被其中一个消费者\footnote{如果有一个包含多个消费者的消费者组订阅顺序主题}消费，从而确保消息的顺序性。
  \item 消费消息时，必须提交消费结果。同一个MessageGroup的消息，如果前序消息没有消费完成，再次调用Receive是获取不到后续消息的。
\end{enumerate}

\subsection{事务消息}
还不会。
% 文章结束
\end{document}